<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    面试 |  WinGone&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="WinGone's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="面试-面试准备"
  class="article article-type-面试"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  面试
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/07/06/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="article-date">
  <time datetime="2019-07-06T09:40:03.000Z" itemprop="datePublished">2019-07-06</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">17k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">61 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="1-hashmap-的底层"><a href="#1-hashmap-的底层" class="headerlink" title="1.hashmap 的底层"></a>1.hashmap 的底层</h3><ul>
<li><p>基于hash算法实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”</span><br></pre></td></tr></table></figure></li>
<li><p>1.7与1.8 区别</p>
<p>两个对象的hashcode相同 </p>
<ul>
<li>存储值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</span><br><span class="line"></span><br><span class="line">1.7采用的数据结构是数组+链表 </span><br><span class="line">1.8 数组+链表+红黑树 </span><br><span class="line">红黑树的引入是为了提高查询效率</span><br><span class="line">链表O(n) 红黑树 O(logn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.7 处理hash碰撞在链表上添加数据的时候 用的是头插法 容易多线程的情况下 循环链表 耗尽cpu性能</span><br><span class="line">1.8 丢数据</span><br></pre></td></tr></table></figure>



<ul>
<li>获取值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置</span><br><span class="line">找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象</span><br></pre></td></tr></table></figure></li>
<li><p>传入初始化容量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们创建hashmap集合的时候最好传入一个初始化的容量，如果传入的值不是2的次幂 他会变成大于它 并且离它最近的一个2的次幂，</span><br></pre></td></tr></table></figure></li>
<li><p>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</span><br></pre></td></tr></table></figure>

<p>​     你了解重新调整HashMap大小存在什么问题吗</p>
<p>   多线程的情况下，可能产生条件竞争 调整大小的过程中，存储在链表中的元素的次序会反过来</p>
<ul>
<li>HashMap Hashtable区别</li>
</ul>
<p>HashMap可以接受null键值和值，而Hashtable则不能；</p>
<p>HashMap是非synchronized;</p>
<h3 id="2-springboot自动配置原理"><a href="#2-springboot自动配置原理" class="headerlink" title="2.springboot自动配置原理"></a>2.springboot自动配置原理</h3><p> <strong>@SpringBootApplication</strong>是一个复合注解或派生注解</p>
<p>↓</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： </p>
<p>@ComponentScan：Spring组件扫描。</p>
<p><strong>@EnableAutoConfiguration</strong>，开启自动配置，派生注解</p>
<p>↓</p>
<p><strong>@Import(AutoConfigurationImportSelector.class)</strong></p>
<p><strong>@Import</strong>提供，其导入的</p>
<p><strong>AutoConfigurationImportSelector</strong></p>
<p>AutoConfigurationImportSelector的**selectImports()<strong>方法通</strong>过SpringFactoriesLoader.loadFactoryNames()**扫描所有具有</p>
<p><strong>META-INF/spring.factories</strong>的jar包。</p>
<p>spring.factories文件。<br>是一组一组的key=value的形式，其中一个</p>
<p>key是EnableAutoConfiguration类的全类名，</p>
<p>value是一个xxxxAutoConfiguration的类名的列表，逗号分隔</p>
<p>main方法启动的时候 就会执行**selectImports()**方法，给容器导入META-INF/spring.factories 里定义的自动配置类。</p>
<p>筛选有效的自动配置类。</p>
<p>每一个自动配置类结合对应的 xxxProperties.java 读取<strong>配置文件</strong>进行自动配置功能</p>
<ul>
<li>bootstrap.properties </li>
</ul>
<p>bootstrap (. yml 或者 . properties)：boostrap 由父 <strong>ApplicationContext 加载的，比 applicaton 优先加载</strong>，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</p>
<ul>
<li>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</li>
</ul>
<p> Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易</p>
<ol>
<li>Spring Security 是一个<strong>重量级</strong>的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li>
<li>Spring Security 概念<strong>复杂</strong>，配置繁琐；Shiro 概念<strong>简单</strong>、配置简单</li>
<li>Spring Security 功能强大；Shiro 功能简单</li>
</ol>
<ul>
<li>Spring Boot 中如何解决跨域问题 ?</li>
</ul>
<p><strong>实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>什么是 WebSockets？</li>
</ul>
<p>WebSocket 是一种计算机通信协议，通过单个 </p>
<p>TCP 连接提供全双工通信信道。</p>
<p>1、WebSocket 是<strong>双向</strong>的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p>
<p>2、WebSocket 是全双工的 -客户端和服务器通信是<strong>相互独立</strong>的。</p>
<p>3、单个 TCP 连接 -<strong>初始连接使用 HTT</strong>P，然后将此连接升级到基于<strong>套接字</strong>的连接。然后这个单一连接用于所有未来的通信</p>
<p>4、Light -与 <strong>http 相比</strong>，WebSocket 消息数据交换要<strong>轻</strong>得多。</p>
<ul>
<li>么是 Spring Data ?</li>
</ul>
<p>Spring Data 是 Spring 的一个子项目</p>
<p>支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。</p>
<ol>
<li><p>Redis（键/值存储）</p>
</li>
<li><p>es</p>
</li>
<li><p>JDBC</p>
</li>
<li><p>JPA</p>
</li>
</ol>
<p>Spring Data Jpa 致力于<strong>减少数据访问层 (DAO) 的开发量</strong>. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！</p>
<ul>
<li>pring Boot项目如何热部署？</li>
</ul>
<p>Spring Boot 有一个开发工具（DevTools）模块，</p>
<ul>
<li>如何使用 Spring Boot 实现异常处理？</li>
</ul>
<p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p>
<h4 id="3-3-Bean-创建流程"><a href="#3-3-Bean-创建流程" class="headerlink" title="3.3 Bean 创建流程"></a>3.3 Bean 创建流程</h4><p>1、初始化所有剩下的⾮懒加载的单例bean</p>
<p>2、初始化创建⾮懒加载⽅式的单例Bean实例（未设置属性）</p>
<p>3、填充属性</p>
<p>4、初始化⽅法调⽤（⽐如调⽤afterPropertiesSet⽅法、init-method⽅法）</p>
<p>5、调⽤BeanPostProcessor（后置处理器）对实例bean进⾏后置处</p>
<h4 id="3-4-Bean-生命周期（11步）"><a href="#3-4-Bean-生命周期（11步）" class="headerlink" title="3.4 Bean 生命周期（11步）"></a>3.4 Bean 生命周期（11步）</h4><p><img src="https://img-blog.csdnimg.cn/20210411115238337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NzkwMDEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>1、根据配置情况调用 Bean的构造方法或者工厂方法实例化Bean</p>
<p>2、利用依赖注入完成Bean的所以属性值的配置注入</p>
<p>3、如果Bean 实现了BeanNameAware 接口，则spring 调用Bean的setBeanName() 传入当前Bean的id</p>
<p>4、如果Bean实现了BeanFactoryAware 接口，调用setBeanFactory() 方法传入当前工厂实例的引用</p>
<p>5、如果Bean 实现了ApplicationContextAware 接口，通过调用setApplicationContext 传入当前applicationContext 实例的引用。</p>
<p>6、如果BeanPostProcessor 和Bean 关联，则Spring 将调用改接口的预初始化方法。postProcessBeforeInitialization() 是前置处理的方法，Spring的AOP就是利用它实现的。</p>
<p>7、如果Bean 实现了InitializingBean 接口,需要实现afterPropertiesSet 方法</p>
<p>8、如果在配置文件中通过init-method 属性指定了初始化方法。则的调用该方法。</p>
<p>9、如果BeanPostProcessor 和Bean 关联，则Spring 将调用该接口的初始化方法postProcessAfterInitialization().此时Bean可以被应用系统使用。</p>
<p>10、如果在Bean标签中指定了Bean的作用范围的scope=“singleton” 则将改Bean 方法singletonObjects的缓存池中</p>
<p>11、如果Bean 实现了DisposableBean 接口，则spring会调用destory() 方法 将Spring中的Bean销毁。</p>
<h4 id="3-5-Autowired-和Resource-注解的区别"><a href="#3-5-Autowired-和Resource-注解的区别" class="headerlink" title="3.5 Autowired 和Resource 注解的区别"></a>3.5 <strong>Autowired 和Resource 注解的区别</strong></h4><p>1、autowired 是spring 提供的注解，@Resource是javaee 提供的注解。</p>
<p>2、Autowired 采用的是按类型注入。当一个类有多个Bean的时候需要配合@Qualifier 来指定唯一的Bean。而@Resource 默认安装byName 自动注入。</p>
<p>3、@Resource 可以执行 name 和type .可以通过type 注入，也可以通过name 来注入。</p>
<h4 id="3-6-循环依赖"><a href="#3-6-循环依赖" class="headerlink" title="3.6 循环依赖"></a>3.6 循环依赖</h4><p>利用三级缓存来解决循环依赖的。</p>
<p>1、当创建对象A的Bean 的时候，会先将A对象Bean 放入三级缓存，然后填充属性；</p>
<p>2、发现依赖对象B ,但是对象B 还没有创建，所以就创建对象B</p>
<p>3、对象B在创建过程中，发现依赖对象A，就先从一级缓存中获取，没有获取到就从二级缓存中找，没有找到就从三级缓存中找，找到了还没有创建完成的对象A .然后将对象A 进行一些处理移入二级缓存中。</p>
<p>4、这样对象B就可以继续完成Bean 创建的其他步骤知道完全创建好。</p>
<p>5、B 对象的Bean 创建好之后，放入了一级缓存SingLetonObject中，对象A可以继续完成创建。最终创建好的A对象也会进入一级缓存中。</p>
<h4 id="3-7-事务的传播行为-7中类型"><a href="#3-7-事务的传播行为-7中类型" class="headerlink" title="3.7 事务的传播行为(7中类型)"></a>3.7 事务的传播行为(7中类型)</h4><p>事务往往在service 层控制，如果在 service 层方法A调用另个 service 的方法 B 。A和B 本身都本身都添加了事务控制，那么在A调用B 的时候就需要进行事务的一些协商，这就是事务的传播行为。</p>
<p>有如下7中类型：</p>
<p>A调用B，站在B的角度来定义传播行为。</p>
<p>1、如果当前没有事务，就新建事务；如果存在一个事物，就加入到当前事务中。这是最常见的一种类型。</p>
<p>2、支持当前事务，如果没有事务，就以非事务执行。</p>
<p>3、支持当前事务，如果没有事务，就抛出异常。</p>
<p>4、新建事务，如果当前存在事务，就将当前事务挂起。</p>
<p>5、以非事务运行，如果存在当前事务，就将当前事务挂起。</p>
<p>6、以非事务运行，如果存在当前事务，就抛出异常。</p>
<p>7、如果当前存在事务，就在嵌套事务内执行。如果当前没有事务，就创建一个事物执行。</p>
<h4 id="3-8-spring-mvc-请求处理流程-10步"><a href="#3-8-spring-mvc-请求处理流程-10步" class="headerlink" title="3.8 spring mvc 请求处理流程(10步)"></a>3.8 spring mvc 请求处理流程(10步)</h4><p>1、DispatcherServlet 接收到客户端发送的请求。</p>
<p>2、DispatcherServlet 收到请求调用HandlerMapping 处理器映射器。</p>
<p>3、HandleMapping 根据请求URL 找到对应的handler 以及处理器 拦截器，返回给DispatcherServlet</p>
<p>4、DispatcherServlet 根据handler 调用HanderAdapter 处理器适配器。</p>
<p>5、HandlerAdapter 根据handler 执行处理器，也就是我们controller层写的业务逻辑，并返回一个ModeAndView</p>
<p>6、HandlerAdapter 返回ModeAndView 给DispatcherServlet</p>
<p>7、DispatcherServlet 调用 ViewResolver 视图解析器来 来解析ModeAndView</p>
<p>8、ViewResolve 解析ModeAndView 并返回真正的view 给DispatcherServlet</p>
<p>9、DispatcherServlet 将得到的视图进行渲染，填充到request域中</p>
<p>10、返回给客户端响应结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411115300545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NzkwMDEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-9-过滤器拦截器"><a href="#3-9-过滤器拦截器" class="headerlink" title="3.9 过滤器拦截器"></a>3.9 过滤器拦截器</h4><ul>
<li>过滤器（Filter）：对Request请求起到过滤的作⽤，作⽤在Servlet之前，如果配置为/*可以对所有的资源访问（servlet、js/css静态资源等）进⾏过滤处理</li>
<li>拦截器（Interceptor）：是SpringMVC、Struts 等表现层框架⾃⼰的，不会拦截 jsp/html/css/image 的访问等，只会拦截访问的控制器⽅法（Handler）。拦截器会作用三个地方：在 handler 执行之前执行一次，用来校验参数合理性，handler 之后、视图解析器之前执行一次，视图解析之后执行一次。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/aedd1ae4cbf681ca1168e58a17bd8eb9.png" alt="image-20200609153128257"></p>
<h4 id="3-10-springboot-启动流程-9步"><a href="#3-10-springboot-启动流程-9步" class="headerlink" title="3.10 springboot 启动流程(9步)"></a>3.10 springboot 启动流程(9步)</h4><p>1、加载并启动监听器</p>
<p>2、创建项目运行环境，并加载配置</p>
<p>3、创建 spring 容器。</p>
<p>4、运行spring 容器的前置处理。主要是容器刷新之前的准备工作，设置容器环境，并且将启动类注入容器，为后面开启自动化配置服务。</p>
<p>5、刷新是spring 容器。通过refresh() 方法对整个IOC 容器初始化。包含bean 资源点定位解析注册等。</p>
<p>6、运行spring 容器后置处理器。扩展接口，如果有自定义需求，可以重写该方法。</p>
<p>7、发布结束执行的事件。</p>
<p>8、执行自定义执行器。</p>
<p>9、返回容器。</p>
<h4 id="3-11-说说-hashMap-的原理"><a href="#3-11-说说-hashMap-的原理" class="headerlink" title="3.11. 说说 hashMap 的原理"></a>3.11. 说说 hashMap 的原理</h4><p>在jdk 1.7 版本，hashmap 的数据结构是 数组加链表</p>
<p>在jdk 1.8 版本，hashmap 的数据结构是数组加链表叫红黑树。当数组长度大于64 且链表长度大于8时，链表就会转换成红黑树。</p>
<h4 id="3-12-synchronized-和-ReentrantLock-的区别"><a href="#3-12-synchronized-和-ReentrantLock-的区别" class="headerlink" title="3.12. synchronized 和 ReentrantLock 的区别"></a>3.12. synchronized 和 ReentrantLock 的区别</h4><p>1、synchronized 是 JVM 隐式实现的，而 ReentrantLock 是 Java 语言提供的 API；</p>
<p>2、ReentrantLock 可设置为公平锁，而 synchronized 却不行；</p>
<p>3、ReentrantLock 只能修饰代码块，而 synchronized 可以用于修饰方法、修饰代码块等；</p>
<p>4、ReentrantLock 需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而 synchronized 无需手动释放锁；</p>
<p>5、ReentrantLock 可以知道是否成功获得了锁，而 synchronized 却不行。</p>
<h3 id="4-jvm"><a href="#4-jvm" class="headerlink" title="4. jvm"></a>4. jvm</h3><h4 id="4-1-jvm-内存模型"><a href="#4-1-jvm-内存模型" class="headerlink" title="4.1 jvm 内存模型"></a>4.1 jvm 内存模型</h4><p>jvm 内存分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。</p>
<p>程序计数器：线程私有。是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。</p>
<p>虚拟机栈：线程私有。用于存储栈帧。每个方法在执行时都会创建一个栈帧(Stack Frame)<strong>，</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>本地方法栈：线程私有。用于 虚拟机 Native 方法</p>
<p>堆：线程共享、保存对象实例，所有的对象实例都在堆上存储。</p>
<p>方法区：线程共享。存储被虚拟机加载的类信息、常量、静态变量等。</p>
<h4 id="4-2-jvm-堆"><a href="#4-2-jvm-堆" class="headerlink" title="4.2 jvm 堆"></a>4.2 jvm 堆</h4><h5 id="4-2-1-堆内存分布"><a href="#4-2-1-堆内存分布" class="headerlink" title="4.2.1 堆内存分布"></a>4.2.1 堆内存分布</h5><p>jvm 将堆内存分为 年轻代和年老代。年轻代和年老代的比例为1:2 。年老代用来存储存活时间比较长或者大对象。年轻代用来存储错过时间比较短的对象。年轻代中又分为Eden 区和两个Survivor 区，比例为8：1：1。</p>
<h5 id="4-2-2-对象分配过程"><a href="#4-2-2-对象分配过程" class="headerlink" title="4.2.2 对象分配过程"></a>4.2.2 对象分配过程</h5><p>1、首先会将对象放入年轻代的 Eden 区，如果Eden 区能发下就放入。</p>
<p>2、如果 Eden 区放不下了，就会触发 YangGC。会对Eden 区和使用的 Survivor 区进行垃圾回收，存活的对象保存到另一个空闲的Survivor 区。然后将新对象放入 Eden 区。</p>
<p>3、当Survivor 区有对象经历 15 次 yangGC 后还存活，就迁移到年老代。15次是默认的，可以调整。</p>
<p>4、如果新增对象大小超过Eden 区 一半时，会直接加入年老区。如果年老区 能放下就放入。</p>
<p>5、如果年老区放不下，就会触发OldGC。</p>
<p>6、如果OldGC 后，还是放不下对象，就会触发FullGC</p>
<p>7、如果FullGC 还放不下，就会报OOM 异常。</p>
<h4 id="4-3-方法区"><a href="#4-3-方法区" class="headerlink" title="4.3 方法区"></a>4.3 方法区</h4><p>方法区保存的内容：类型信息、域信息、方法信息、运行时常量池。元空间用来存储类的元信息，存储位置为本地内存。静态变量和常量池存储在堆中。</p>
<h4 id="4-4-类加载的执行过程"><a href="#4-4-类加载的执行过程" class="headerlink" title="4.4 类加载的执行过程"></a>4.4 类加载的执行过程</h4><p>类的生命周期：包含7个阶段，有加载、验证、准备、解析、初始化、使用和卸载。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bdc769f2910362ead861ed57916b7bef.png" alt="image-20210303135001897"></p>
<p>加载：分为预加载和运行时加载、预加载是在JVM启动的时候就加载的class 文件。加载的都是lib/rt.jar 下的 .class 文件。运行时加载是指我们一般的class 文件，只有在用到的时候会先去内存中查一下有没有，没有才会进行加载到内存中。主要获取 .class 文件的二进制流。类信息、静态变量、字节码、常量这些信息会存入 方法区中。</p>
<p>连接分为验证、准备和解析</p>
<p>验证：保证 .class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。</p>
<p>准备：为类的变量分配内存并设置其初始值。这里的初始值是 默认初始值。，比如”public static int value = 123”，value在准备阶段过后是0而不是123，给value赋值为123的动作将在初始化阶段才进行；比如”public static final int value = 123;”就不一样了，在准备阶段，虚拟机就会给value赋值为123。</p>
<p>解析：是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用是一种定义，可以是任何字面上的含义，而直接引用就是直接指向目标的指针、相对偏移量。</p>
<p>初始化：类的初始化阶段是类加载的最后一个过程。初始化阶段就是执行类构造器方法的过程。为类变量进行初始化赋值。这里就是我们代码中定义的值了。</p>
<h4 id="4-5-双亲委派模型"><a href="#4-5-双亲委派模型" class="headerlink" title="4.5 双亲委派模型"></a>4.5 双亲委派模型</h4><p>如果一个类加载器收到类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给自己的父类加载器完成，每个类加载器都是如此，只有当父类加载器在自己范围内找不到指定类时，又会委派自己的子类进行加载。这就是双亲委派模型。这样做的好处是：让类加载尽量都交给父类加载，这样就可以避免不同的子类都需要进行类加载，提升了效率，也更加安全。</p>
<h4 id="4-6-判断对象已死算法"><a href="#4-6-判断对象已死算法" class="headerlink" title="4.6 判断对象已死算法"></a>4.6 判断对象已死算法</h4><p>1、引用计数算法。当该对象被应用了，计数器就+1，引用失效了，就-1。当计数器值为0 时表示没有被使用，可以回收了。不能解决循环引用的问题。</p>
<p>2、可达性分析算法。从一系类的 GC root 的对象作为起点，向下搜索到对象的路劲。如果对象没有和 GC root 对象不存在路劲。就会被标记需要清除。</p>
<p>GC root 对象有哪些？</p>
<p>1、栈帧中局部变量表的reference 引用所引用的对象。</p>
<p>2、方法区中 static 静态引用的对象。</p>
<p>3、方法区中final 常量引用的对象。</p>
<p>4、所有被同步锁持有的对象。</p>
<p>5、java 虚拟机内部的引用，如基本数据类型的对象、异常对象、系统类加载器等</p>
<p>finalize() 方法</p>
<p>如果对象进行可达性分析，发现对象没有和 GCroot 相连接的引用链，会被第一次标记，随后进行一次筛选，判断是否有必要执行 finalize() 方法。</p>
<p>如果没有重载finalize() 方法，或者虚拟机已经执行过了该对象的 finalize() 方法，则判定为没有必要，直接等待回收。如果判定有必要执行 finalize() 方法。就会放入F-Queue 队列中，随后由低优先级的线程执行 finalize() 方法。在方法中，可以将当前对象和GCroot 对象建立引用链，摆脱被回收的命运。否则执行完 finalize() 依旧会被回收。</p>
<h4 id="4-7-引用类型"><a href="#4-7-引用类型" class="headerlink" title="4.7 引用类型"></a>4.7 引用类型</h4><p>java虚拟机有4中引用类型：</p>
<p>强引用：进行垃圾回收时，垃圾回收器不会对强引用的对象进行回收。</p>
<p>软引用：只要内存足够，垃圾回收器就就不会回收，只要当内存不足时才会对软引用的对象进行回收。</p>
<p>弱引用：在垃圾回收器执行垃圾回收时，不管内存够不够，都会对弱引用的对象进行回收。</p>
<p>虚引用： 它是最弱的一种引用关系。如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p>
<h4 id="4-8-垃圾回收算法"><a href="#4-8-垃圾回收算法" class="headerlink" title="4.8 垃圾回收算法"></a>4.8 垃圾回收算法</h4><h5 id="4-8-1-分代收集理论"><a href="#4-8-1-分代收集理论" class="headerlink" title="4.8.1 分代收集理论"></a>4.8.1 分代收集理论</h5><p>基于两个假说：</p>
<p>1、大部分对象都是朝生熄灭的</p>
<p>2、存活时间越久的对象越难以消亡。</p>
<h5 id="4-8-2-标记清除算法"><a href="#4-8-2-标记清除算法" class="headerlink" title="4.8.2 标记清除算法"></a>4.8.2 标记清除算法</h5><p>算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回 收的对象， 在标记完成后，统一回收掉所有被标记的对象， 也可以反过来， 标记存活的对象， 统一回收所有未被标记的对象</p>
<p><img src="https://img-blog.csdnimg.cn/20210411115334115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NzkwMDEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>缺点：内存空间碎片化严重。</p>
<h5 id="4-8-3-标记复制算法"><a href="#4-8-3-标记复制算法" class="headerlink" title="4.8.3 标记复制算法"></a>4.8.3 标记复制算法</h5><p>当这一块的内存用完了， 就将还存活着 的对象复制到另外一块上面， 然后再把已使用过的内存空间一次清理掉。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411115352671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NzkwMDEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>缺点：每次有一半的内存空闲，利用率不高。如果99%的对象都是存活的（老年代），那么老年代是无法使用这种算法的。</p>
<h5 id="4-8-4-标记整理算法"><a href="#4-8-4-标记整理算法" class="headerlink" title="4.8.4 标记整理算法"></a>4.8.4 标记整理算法</h5><p>的“标记-整 理”（Mark-Compact） 算法， 其中的标记过程仍然与“标记-清除”算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411115422458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NzkwMDEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-9-垃圾收集器"><a href="#4-9-垃圾收集器" class="headerlink" title="4.9 垃圾收集器"></a>4.9 垃圾收集器</h4><h5 id="4-9-1-CMS-收集器"><a href="#4-9-1-CMS-收集器" class="headerlink" title="4.9.1 CMS 收集器"></a>4.9.1 CMS 收集器</h5><p>CMS 收集器分为4个步骤：</p>
<p>1、初始标记： 这个阶段会stop-the-world 。主要是来标记 GC roots 能够直接关联到的对象。标记之后恢复暂停的所有应用。操作速度是比较快的。</p>
<p>2、并发标记：这个阶段是GC roots 直接关联到的对象开始遍历标记整个对象图的过程，耗时较长，但不用暂停用户线程。可以并发执行。</p>
<p>3、重新标记：为了修正并发标记阶段用户线程运行导致标记发生变动，从而进行重新标记，也会stop-the-world 。耗时比初始标记会长一点。</p>
<p>4、并发清理：清理哪些被标记为死亡的对象，并释放内存空间。采用标记清除算法，不用移动存活对象，可以并发执行。</p>
<h5 id="4-9-2-G1-收集器"><a href="#4-9-2-G1-收集器" class="headerlink" title="4.9.2 G1 收集器"></a>4.9.2 G1 收集器</h5><p>G1 收集器特点：</p>
<p>1、G1 把堆内存分为多个独立的 region 区域。</p>
<p>2、G1 沿用了分代思想。保留了年轻代、年老代。但他们不再物理隔离。都通过Region 存储。</p>
<p>3、G1 采用标记整理算法，局部采用标记复制算法。不会产生内存碎片化。</p>
<p>4、G1 能充分利用多CPU 、多核硬件环境，尽量缩短STW</p>
<p>过程：</p>
<p>初始标记：和CMS 初始标记阶段一样，标记 GC roots 能够直接关联到的对象。会STW</p>
<p>并发标记：和CMS 并发标记阶段一样。GC roots 直接关联的对象整个对象树进行标记。</p>
<p>最终标记：修正并发标记阶段，因程序运行产生变化的那部分对象。</p>
<p>筛选回收：根据时间来进行价值最大化收集。</p>
<h5 id="4-9-3-ZGC-收集器"><a href="#4-9-3-ZGC-收集器" class="headerlink" title="4.9.3 ZGC 收集器"></a>4.9.3 ZGC 收集器</h5><p>ZGC 是java 11 版本中提供的高效垃圾回收算法，有以下特点：</p>
<p>1、使用了着色指针技术，利用指针额外信息位，在指针上对对象进行着色标记。</p>
<p>2、使用了读屏障，使得进行垃圾回收大部分时间都不需要STW,因此大部分时间都是并发处理的。</p>
<p>3、基于Region ,没有进行分代，也灭有固定Region 的大小，Region 是可以动态创建和销毁的。对大对象可以更好的管理。</p>
<p>4、压缩整理。在回收后会对 Region 对象进行移动合并，解决碎片化问题。</p>
<p>过程：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/882f4aafc7d4d868e1a24a3eda39a6ef.png" alt="image-20210304135404162"></p>
<p>1、初始标记：在开始的时候会有短暂的 STW ,用户标记 GC Roots。</p>
<p>2、并发标记：这个阶段通过对象指针着色来标记，结合读屏障解决单个对象的并发问题。在最后会有一个短暂的STW 来解决边缘情况。</p>
<p>3、清理阶段：这个阶段会对不再使用的对象进行回收。</p>
<p>4、并发重定位：就是对存活的对象进行移动，来解决碎片化的问题。也是利用读屏障和用户线程并发处理的。</p>
<h3 id="5-设计模式"><a href="#5-设计模式" class="headerlink" title="5. 设计模式"></a>5. 设计模式</h3><h4 id="5-1-单例模式"><a href="#5-1-单例模式" class="headerlink" title="5.1 单例模式"></a>5.1 单例模式</h4><p>保证一个类仅有一个实例，并提供一个访问它的方法。包含一个静态变量，一个私有的构造方法，一个 public 的静态方法。</p>
<p>饿汉式、懒汉式、双重校验锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingLeton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> volalite <span class="keyword">static</span> SingLeton sing;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingLeton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingLeton <span class="title">getSingLeton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sing==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(SingLeton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sing==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    sing=<span class="keyword">new</span> SingLeton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sing;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingLeton</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingLetonInner</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingLeton sing=<span class="keyword">new</span> SingLeton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingLeton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingLeton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingLetonInner.sing;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-工厂模式"><a href="#5-2-工厂模式" class="headerlink" title="5.2 工厂模式"></a>5.2 工厂模式</h4><p>工厂模式就是通过工厂来创建想要的对象，而不是自己去创建对象。这样降低了代码间的耦合度。比如一个服饰工厂可以生产衣服，裤子，鞋子，袜子，帽子等等。我们想要用衣服，不用自己来造了，而是和工厂说你想要什么，那工厂就给你生产什么。这就是工厂模式。主要是将创建对象的实例交给工厂类来完成，并进行管理。</p>
<p>工厂分为简单工厂模式、工厂方法模式和抽象工厂模式。</p>
<p><strong>简单工厂模式</strong>：是工厂模式最简单的一种，实例有工厂直接创建。也就是上面的例子中，你想要衣服，那这个服饰工厂就给你做一件衣服给你。</p>
<p><strong>工厂方法模式</strong> ：就是工厂本身不进行实体对象的创建，而是通过对应的下游工厂来创建然后在返回，有点总工厂子工厂的意思，总工厂管理着所有的子工厂，每个子工厂只生产指定的商品，当通知总部想要什么东西时，总部就通知对应的子工厂生产，拿到产品后再返回客户。</p>
<p><strong>抽象工厂</strong>：就是一个抽象工厂类，里面只是声明可以实现哪些对象，但是具体的实现就交给具体的工厂完成。抽象工厂就好比包皮公司，它告诉你他可生产服饰，也就可以生产食品。那比如你想要衣服，它就给你一个服饰工厂的联系方式，你通过这个服饰工厂来获取到衣服。想要辣条，那他就给你推一个食品公司的联系方式，让这个食品公司给你做。</p>
<p>工厂方法模式和抽象工厂模式的区别：在于工厂方法模式主要是生产某一类商品。而抽象工厂，我不关心你怎么实现，只要你说你能做这个商品，我就可以为你代言。</p>
<h4 id="5-3-构建者模式"><a href="#5-3-构建者模式" class="headerlink" title="5.3 构建者模式"></a>5.3 构建者模式</h4><p>将构建一个复杂的对象可以进行拆分成构建一个个简单的对象。然后组装成复杂的对象，就是构建者模式。比如mybatis 中为了构建Configuration 这个复杂对象，就先构建了Dadasource、MapperStment、等很多的对象组成，在解析SqlMapConfig配置文件的时候，就会先将各种配置文件封装到对应的对象中，最后组装成 Configuration 对象</p>
<h4 id="5-4-代理模式"><a href="#5-4-代理模式" class="headerlink" title="5.4 代理模式"></a>5.4 代理模式</h4><p>代理模式就是我们想要执行的方法通过代理对象来完成，就好比我们要抢票回家，我们不想自己盯着抢，所以就找代理帮我们抢从而达到目的。代理模式分为静态代理和动态代理。</p>
<p><strong>静态代理</strong>：就是具体的代理类，在编译阶段就知道这个代理能做什么事情。就好比抢票的代理一样，它只能做抢票这个代理，而不能代你抢钱哈哈。</p>
<p><strong>动态代理</strong>：动态代理就不同了，它在编译阶段也没有具体的实现。而是在程序运行期间根据JVM的反射机制动态生成的。比较出名的就JDK 动态代理 和cglib 动态代理。</p>
<p>JDK 动态代理：主要实现InvocationHandle 接口并实现其 invoke 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 前置增强</span></span><br><span class="line">                       ....</span><br><span class="line">                        <span class="comment">// 调用原有业务逻辑</span></span><br><span class="line">                        result = method.invoke(obj,args);</span><br><span class="line">                        <span class="comment">//后置增强</span></span><br><span class="line">                        ...</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>

<p>cglib 动态代理：需要引入其依赖，使用方法和JDK动态代理差不多。实现MethodInterceptor 接口并实现 intercept 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getCglibProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  Enhancer.create(obj.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//前置增强</span></span><br><span class="line">                ...</span><br><span class="line">                result = method.invoke(obj,objects);</span><br><span class="line">                <span class="comment">//后置增强</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>JDK 动态代理是java 语言自带的功能，提供了稳定的支持。是通过拦截器和反射实现的，jdk 动态代理只能代理继承接口的类。</p>
<p>cglib 动态代理是第三方提供的工具，基于ASM 实现的，性能比较高，cglib 动态代理无需通过接口实现，它是通过实现子类的方式来完成调用的。</p>
<h4 id="5-5-适配器模式"><a href="#5-5-适配器模式" class="headerlink" title="5.5 适配器模式"></a>5.5 适配器模式</h4><h3 id="6-数据结构和算法"><a href="#6-数据结构和算法" class="headerlink" title="6. 数据结构和算法"></a>6. 数据结构和算法</h3><h4 id="6-1-数据结构"><a href="#6-1-数据结构" class="headerlink" title="6.1 数据结构"></a>6.1 数据结构</h4><p>常见的数据结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/202104111154474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NzkwMDEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="6-1-1-线性表"><a href="#6-1-1-线性表" class="headerlink" title="6.1.1 线性表"></a>6.1.1 线性表</h5><h6 id="6-1-1-1数组"><a href="#6-1-1-1数组" class="headerlink" title="6.1.1.1数组"></a>6.1.1.1数组</h6><p>有限个相同类型的变量组成的集合。物理地址连续(连续的内存空间存储)。</p>
<p>删除和插入元素的时候，后续的元素需要进行位移。</p>
<p>扩容数组的时候，需要先创建一个新数据，然后将原数组的值填充到新数组中。</p>
<p>优点：具有高效的随机访问能力。只需要给出下标，就可以常量时间找到对应元素。</p>
<p>缺点：插入和删除，会导致其他元素发生位移。影响效率。</p>
<h6 id="6-1-1-2链表"><a href="#6-1-1-2链表" class="headerlink" title="6.1.1.2链表"></a>6.1.1.2链表</h6><p>链表是物理上不连续的节点组成。每个节点包含两部分。存储数据元素以及指向下个节点的指针。</p>
<p>常见的链表有：单链表，双链表，循环链表。</p>
<p>优点：插入，删除、更新的效率高。</p>
<p>缺点：查询的效率低，不能随机访问。在查询节点的时候，只能从头结点开始一个个的往后找。</p>
<h6 id="6-1-1-3-栈"><a href="#6-1-1-3-栈" class="headerlink" title="6.1.1.3 栈"></a>6.1.1.3 栈</h6><p>栈是一种线性结构，栈中的元素只能先入后出。最早进入的元素为栈底，最后进入的元素叫栈顶。</p>
<p>栈可以用数组实现也可以用链表实现。</p>
<h6 id="6-1-1-4-队列"><a href="#6-1-1-4-队列" class="headerlink" title="6.1.1.4 队列"></a>6.1.1.4 队列</h6><p>队列也是一种线性结构，只能先入先出。队列的出口端叫做队头，队列的入口端加做队尾。</p>
<p>队列可以用数组实现也可以用链表实现。</p>
<h5 id="6-1-2-散列表"><a href="#6-1-2-散列表" class="headerlink" title="6.1.2 散列表"></a>6.1.2 散列表</h5><p>散列表也是 hash 表。这种数据结构提供了key 和value 的映射关系。只要给出 key ,就可以高效的查询出它所匹配的 value 。</p>
<h5 id="6-1-3-树"><a href="#6-1-3-树" class="headerlink" title="6.1.3 树"></a>6.1.3 树</h5><p>树又分为二叉树和多叉树。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/00ab373c47eaf1d800ef041f6603b24a.png" alt="image-20210219105937939"></p>
<h6 id="6-1-3-1-二叉树"><a href="#6-1-3-1-二叉树" class="headerlink" title="6.1.3.1 二叉树"></a>6.1.3.1 二叉树</h6><p>二叉树每个节点最多只有两个子节点。</p>
<h6 id="6-1-3-2-满二叉树"><a href="#6-1-3-2-满二叉树" class="headerlink" title="6.1.3.2 满二叉树"></a>6.1.3.2 满二叉树</h6><p>一个二叉树所有的非叶子节点都存在左右子节点。且所有的叶子节点都在同一层，就是满二叉树。</p>
<h6 id="6-1-3-3-完全二叉树"><a href="#6-1-3-3-完全二叉树" class="headerlink" title="6.1.3.3 完全二叉树"></a>6.1.3.3 完全二叉树</h6><p>如果二叉树的深度为k。k-1 层为满二叉树。第k 层，所有节点都连续集中在最左边，则是一颗完全二叉树。</p>
<h6 id="6-1-3-4-平衡二叉树"><a href="#6-1-3-4-平衡二叉树" class="headerlink" title="6.1.3.4 平衡二叉树"></a>6.1.3.4 平衡二叉树</h6><p>左子树和右子树的深度差的绝对值不超过1。并且左子树和右子树也为平衡二叉树。</p>
<h6 id="6-1-3-5-二叉查找树"><a href="#6-1-3-5-二叉查找树" class="headerlink" title="6.1.3.5 二叉查找树"></a>6.1.3.5 二叉查找树</h6><p>在二叉树的基础上。如果有左节点，左节点的的值都小于根节点。如果有右节点，右节点的值都大于根节点。二叉查找树又叫二叉排序树。</p>
<h6 id="6-1-3-6-红黑树"><a href="#6-1-3-6-红黑树" class="headerlink" title="6.1.3.6 红黑树"></a>6.1.3.6 红黑树</h6><p>一种自平衡的二叉查找树。有以下特征：</p>
<p>1、每个节点不是红色节点就是黑色节点。</p>
<p>2、根节点是黑色。</p>
<p>3、每个叶子节点都是黑色的空节点。</p>
<p>4、如果一个节点是红色的。那么它的子节点必须为黑色。</p>
<p>5、每个节点到各个叶子节点的包含相同数量的黑节点。</p>
<p>6、新加入的节点为红色，然后校验是否满足红黑树的规则，。如果不满足则需要进行颜色翻转、左旋、右旋等操作。</p>
<h6 id="6-1-3-7-B-树"><a href="#6-1-3-7-B-树" class="headerlink" title="6.1.3.7 B 树"></a>6.1.3.7 B 树</h6><p>B 树为一种多叉树。一颗 M 阶的B 树 特征如下：</p>
<p>1、树的每个节点至多有M 个子节点。</p>
<p>2、根节点至少有两个子节点。</p>
<p>3、除根节点外，其他非叶子节点至少有 m/2 个子节点。</p>
<p>4、所有叶子节点都在同一层。</p>
<h6 id="6-1-3-8-B-树"><a href="#6-1-3-8-B-树" class="headerlink" title="6.1.3.8 B+ 树"></a>6.1.3.8 B+ 树</h6><p>B+ 树是B树的变种。如下特征：</p>
<p>1、多路平衡树</p>
<p>2、只有叶子节点保存数据</p>
<p>3、搜索时 也相当于二分查找</p>
<p>4、增加了相邻叶子节点指针</p>
<h4 id="6-2-算法"><a href="#6-2-算法" class="headerlink" title="6.2 算法"></a>6.2 算法</h4><p>常见的算法如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9df2734f043f0c4cfaa582e18a1bdd45.png" alt="image-20210218160809562"></p>
<h5 id="6-2-1-排序"><a href="#6-2-1-排序" class="headerlink" title="6.2.1 排序"></a>6.2.1 排序</h5><h6 id="6-2-1-1-冒泡"><a href="#6-2-1-1-冒泡" class="headerlink" title="6.2.1.1 冒泡"></a>6.2.1.1 冒泡</h6><p>相邻的两个元素比较，左边大于右边则进行交换。时间复杂度O(n^2)。是稳定排序</p>
<h6 id="6-2-1-2-快排"><a href="#6-2-1-2-快排" class="headerlink" title="6.2.1.2 快排"></a>6.2.1.2 快排</h6><p>快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。每次选择一个基准元素，将比基准元素大的元素放到右边，比基准小的元素放到左边。然后分别对左右进行快排。是不稳定的排序</p>
<h6 id="6-2-1-3-堆排序"><a href="#6-2-1-3-堆排序" class="headerlink" title="6.2.1.3 堆排序"></a>6.2.1.3 堆排序</h6><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。是不稳定的排序。</p>
<h3 id="7-消息队列"><a href="#7-消息队列" class="headerlink" title="7. 消息队列"></a>7. 消息队列</h3><p>主流的消息队列有RabbitMQ、kafka、RocketMQ。三者各有优劣。RocketMQ 支撑高并发高可用的。</p>
<h4 id="7-1-消息队列的使用场景"><a href="#7-1-消息队列的使用场景" class="headerlink" title="7.1 消息队列的使用场景"></a>7.1 消息队列的使用场景</h4><p>比如 创建订单减少库存、以及秒杀场景就可以使用消息队列。消息队列的使用，主要有三大优点：降低耦合、流量削峰填谷、异步。在一些不需要同步处理的场景，可以先把请求保存到消息队列中，直接返回结果给前端。提升响应速度。后续再进行消息的处理。如我们感知项目中，对没有接口日志都要进行日志入库的操作。我们之前是返回结果之前，将请求信息写入日志文件，后台线程定期执行入库。这样做将业务和日志入库进行了强耦合，进行了磁盘io ，接口的整体响应效率受到影响。后面引入 RocketMQ，接口再响应之前，向RocketMQ 中发送一条请求的消息后就返回给前端了。然后单独启用一个日志入库的服务消费RocketMQ 中的日志消息，进行日志入库。</p>
<h4 id="7-2-RocketMQ-的角色"><a href="#7-2-RocketMQ-的角色" class="headerlink" title="7.2 RocketMQ 的角色"></a>7.2 RocketMQ 的角色</h4><ul>
<li><p>Producer：消息的发送者；Producer与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p>
</li>
<li><p>Consumer：消息接收者；Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还 是Slave拉取。</p>
</li>
<li><p>Broker：暂存和传输消息；Broker分为Master与Slave，一个Master可以对应多个Slave，Master与Slave 的对应关系通过指定相同的BrokerName，不</p>
<p>同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</p>
</li>
<li><p>NameServer：管理Broker；是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
</li>
<li><p>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息</p>
</li>
<li><p>Message Queue：相当于是Topic的分区；用于并行发送和接收消息</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/39af6bc0ef626a84c703e93f4281579c.png" alt="image-20210224105151502"></p>
<h4 id="7-3-RocketMQ-的执行流程"><a href="#7-3-RocketMQ-的执行流程" class="headerlink" title="7.3 RocketMQ 的执行流程"></a>7.3 RocketMQ 的执行流程</h4><p>1、启动 NameServer，NameServer 起来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。</p>
<p>2、Broker 启动，跟所有的 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker 信息(IP+端口等)以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</p>
<p>3、收发消息前，先创建 Topic，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker上，也可以在发送消息时自动创建 Topic。</p>
<p>4、Producer 发送消息，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker 发消息。</p>
<p>5、Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息</p>
<h4 id="7-4-RocketMQ-消息过滤"><a href="#7-4-RocketMQ-消息过滤" class="headerlink" title="7.4 RocketMQ 消息过滤"></a>7.4 RocketMQ 消息过滤</h4><p>RocketMQ 的消息过滤主要是在 consumer 端订阅消息时再做消息过滤的。主要基于 Tag 进行过滤。consumer 在订阅消息时，除了指定 topic 还可以指定 tag 。根据 tag 来过滤消息。</p>
<h4 id="7-5-零拷贝"><a href="#7-5-零拷贝" class="headerlink" title="7.5 零拷贝"></a>7.5 零拷贝</h4><p>所谓的零拷贝就是数据在项目的虚拟内存和服务器的物理内存之间没有发生数据拷贝。正常的数据和磁盘的交互流程是。数据首先在项目的虚拟内存中，然后拷贝到物理内存，最后拷贝到磁盘上。读取的话先从磁盘到物理内存，再到项目的虚拟内存。使用零拷贝技术可以减少拷贝的次数。内存中不发生数据拷贝，提升数据传输效率。</p>
<h4 id="7-6-同步复制异步复制"><a href="#7-6-同步复制异步复制" class="headerlink" title="7.6 同步复制异步复制"></a>7.6 同步复制异步复制</h4><p>如果一个broker 组中存在master 和slave .消息需要从 master 同步到 slave.有同步复制和异步复制两种方式。</p>
<p>同步复制：是等 master 和 slave 都写入成功后才返回客户端写成功状态。</p>
<p>异步复制：只等 master 写入成功就返回。</p>
<p>Master 角色的broker 支持读和写。slave 角色的broker 仅支持读。consumer 可以连接master 或者slave 进行消息的读取。</p>
<h4 id="7-7-刷盘机制"><a href="#7-7-刷盘机制" class="headerlink" title="7.7 刷盘机制"></a>7.7 刷盘机制</h4><p>RocketMQ 的所有消息都是持久化的，消息会先写入物理内存，然后刷盘保存到磁盘上。刷盘有同步刷盘和异步刷盘</p>
<p>同步刷盘：同步刷盘等待消息保存到了磁盘后才返回。</p>
<p>异步刷盘：消息保存到了物理内存就返回了。</p>
<h4 id="7-8-延时消息"><a href="#7-8-延时消息" class="headerlink" title="7.8 延时消息"></a>7.8 延时消息</h4><p>延时消息是指消息发送到 broker 后，不会立即被消费。而是等待特定的时间投递给真正的topic .一共有18个等级。可以通过messageDelayLevel 配置。最久延时2小时。</p>
<h4 id="7-9-事务消息"><a href="#7-9-事务消息" class="headerlink" title="7.9 事务消息"></a>7.9 事务消息</h4><p>RocketMQ 采用的是两阶段提交的方式实现事务消息。</p>
<p>流程如下：</p>
<p>1、发送方向RocketMQ发送“待确认”消息。</p>
<p>2、RocketMQ将收到的“待确认”消息持久化成功后，向发送方回复消息已经发送成功，此时第一阶段消息发送完成。</p>
<p>3、发送方开始执行本地事件逻辑。</p>
<p>4、发送方根据本地事件执行结果向 RocketMQ 发送二次确认（Commit或是Rollback）消息。RocketMQ收到Commit状态则将第一阶段消息标记为可投递，订阅方将能够收到该消息；收到 Rollback 状态则删除第一阶段的消息，订阅方接收不到该消息。</p>
<h4 id="7-10-顺序消息"><a href="#7-10-顺序消息" class="headerlink" title="7.10 顺序消息"></a>7.10 顺序消息</h4><p>实现顺序消息的话，只需要生产者只往一个队列中发送消息，并且发送模式调整为同步发送。这样就可以保证消费中从这个队列中消费的消息都是有序的。</p>
<h3 id="8-mysql"><a href="#8-mysql" class="headerlink" title="8. mysql"></a>8. mysql</h3><h3 id="8-1-mysql-体系架构"><a href="#8-1-mysql-体系架构" class="headerlink" title="8.1 mysql 体系架构"></a>8.1 mysql 体系架构</h3><p>mysql server 架构分为：网络连接层、服务层、存储引擎层、和系统文件层。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d0d35f2f47495b632855e802caf59b9b.png" alt="image-20200830103406681"></p>
<p>网络连接层：客户端连接器提供与 mysql 服务端连接的支持。java、c、typhon 通过各自的 api 与 mysql 进行连接。</p>
<p>服务层：系统管理和控制工具、连接池、SQL 接口、解析器、查询优化器、缓存。</p>
<h4 id="8-2-mysql-运行机制"><a href="#8-2-mysql-运行机制" class="headerlink" title="8.2 mysql 运行机制"></a>8.2 mysql 运行机制</h4><p>1、建立连接。mysql 客户端和服务端通信方式为半双工。也就是某一时刻，只能接受数据或者发送数据。</p>
<p>2、查询缓存。先在缓存中查询是否有完全一致的 sql ,如果存在就直接将结果返回。</p>
<p>3、解析器解析。解析器将 sql 进行语法解析，检测语法是否正确。</p>
<p>4、查询优化器根据解析树生成最优的执行计划。</p>
<p>5、查询存储引擎执行计划返回结果。</p>
<h4 id="8-3-mysql-存储引擎InnoDB"><a href="#8-3-mysql-存储引擎InnoDB" class="headerlink" title="8.3 mysql 存储引擎InnoDB"></a>8.3 mysql 存储引擎InnoDB</h4><p>InnoDB 支持事务、有行锁。支持多种索引。主要分为内存结构和磁盘结构两大部分。</p>
<h5 id="8-3-1-内存结构"><a href="#8-3-1-内存结构" class="headerlink" title="8.3.1 内存结构"></a>8.3.1 内存结构</h5><p>内存结构包含：buffer pool 、change buffer、log buffer、Adaptive Hash index 四部分。</p>
<p>1、buffer pool（缓冲池）。以page 为基本单位，在InnoDB 访问表和索引时会在 Page 页中缓存，从而下次查询的时候从 缓冲池中查找，从而减少 磁盘的IO ,提升效率。</p>
<p>2、change buffer(写缓存)。主要在进行增删改的操作是，如果 buffer pool 中没有对应的 Page 数据。并不会立刻从磁盘页中加载数据到缓存池，而是先在 change buffer 中记录下来，等下次数据读取时，再将数据合并到buffer pool 中。减少IO ,提升效率。</p>
<p>3、Adaptive Hash Index (自适应哈希索引)，用户优化对缓存池的查询。</p>
<p>4、Log buffer(日志缓冲区)。用来保存要写入磁盘的 undo/redo 数据 。</p>
<h4 id="8-4-mysql-索引"><a href="#8-4-mysql-索引" class="headerlink" title="8.4 mysql 索引"></a>8.4 mysql 索引</h4><p>mysql 索引可以提升查询效率。有如下索引类型</p>
<p>从应用层次划分：普通索引、唯一索引、主键索引、复合索引</p>
<p>从数据存储和索引键值逻辑关系划分：聚集索引（聚簇索引）、非聚集索引（非聚簇索引）</p>
<h5 id="8-4-1-普通索引"><a href="#8-4-1-普通索引" class="headerlink" title="8.4.1 普通索引"></a>8.4.1 普通索引</h5><p>最普通的索引类型，基于普通字段简历的索引，没有任何限制。</p>
<h5 id="8-4-2-唯一索引"><a href="#8-4-2-唯一索引" class="headerlink" title="8.4.2 唯一索引"></a>8.4.2 唯一索引</h5><p>和普通所以的区别，索引字段的值必须唯一，但是可以为空值。</p>
<h5 id="8-4-3-主键索引"><a href="#8-4-3-主键索引" class="headerlink" title="8.4.3 主键索引"></a>8.4.3 主键索引</h5><p>它是一种特殊的索引，不允许有空值，且字段值必须唯一。一张表只能有一个主键，也只能有一个主键索引。</p>
<h5 id="8-4-4-复合索引"><a href="#8-4-4-复合索引" class="headerlink" title="8.4.4 复合索引"></a>8.4.4 复合索引</h5><p>复合索引是对表的多个字段创建的联合索引。</p>
<p>如果表已经建立了(col1，col2)，就没有必要再单独建立（col1）；如果现在有(col1)索引，如果查询需要col1和col2条件，可以建立(col1,col2)复合索引，对于查询有一定提高。</p>
<h5 id="8-4-5-聚集索引"><a href="#8-4-5-聚集索引" class="headerlink" title="8.4.5 聚集索引"></a>8.4.5 聚集索引</h5><p>B+树叶子节点存放的索引值和行记录就属性聚集索引，如果叶子节点只存储了索引值和主键 那就是非聚集索引。</p>
<p>简单说不需要回表查询的就是聚集索引，需要回表查询的就是非聚集索引。主键索引就是聚集索引。</p>
<h5 id="8-4-6-索引原理"><a href="#8-4-6-索引原理" class="headerlink" title="8.4.6 索引原理"></a>8.4.6 索引原理</h5><p>Mysql 索引采用的是B+ 树的数据结构。</p>
<p>1、非叶子节点不存储数据，值存储索引值。</p>
<p>2、叶子节点包含在同一层，包含所有的索引值和数据。</p>
<p>3、相邻的叶子节点通过指针连接，提高区间访问性能。</p>
<h5 id="8-4-7-like-查询"><a href="#8-4-7-like-查询" class="headerlink" title="8.4.7 like 查询"></a>8.4.7 like 查询</h5><p>MySQL 在使用 Like 模糊查询时，索引是可以被使用的，只有把%字符写在后面才会使用到索引。</p>
<h5 id="8-4-8-explain-有哪些字段"><a href="#8-4-8-explain-有哪些字段" class="headerlink" title="8.4.8 explain 有哪些字段"></a>8.4.8 explain 有哪些字段</h5><p>1、select_type 表示查询类型。常用值有SIMPLE</p>
<p>2、type 表示存储引擎查询数据时采用的方式。ALL 全表查询、index 基于索引的全表扫描、range 范围查询、ref 索引查询。</p>
<p>3、possible_keys 表示查询时能够使用到的索引。</p>
<p>4、key：表示查询时真正使用到的索引，显示的是索引名称。</p>
<h5 id="8-4-9-慢查询优化"><a href="#8-4-9-慢查询优化" class="headerlink" title="8.4.9 慢查询优化"></a>8.4.9 慢查询优化</h5><p>先分析慢查询的原因：</p>
<p>1、全表扫描</p>
<p>2、全索引扫描</p>
<p>3、索引过滤性不好</p>
<p>4、频繁的回表查查询</p>
<p>如果没有使用索引就创建所以，如果索引效率不高，就优化索引，最好使用覆盖索引。避免回表查询。</p>
<h4 id="8-5-mysql-锁"><a href="#8-5-mysql-锁" class="headerlink" title="8.5 mysql 锁"></a>8.5 mysql 锁</h4><h5 id="8-5-1-锁分类"><a href="#8-5-1-锁分类" class="headerlink" title="8.5.1 锁分类"></a>8.5.1 锁分类</h5><p>在 MySQL中锁有很多不同的分类</p>
<ul>
<li>从操作的粒度可分为表级锁、行级锁和页级锁。<ul>
<li>表级锁：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB 等存储引擎中。</li>
<li>行级锁：每次操作锁住一行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB 存储引擎中。</li>
<li>页级锁：每次锁定相邻的一组记录，锁定粒度界于表锁和行锁之间，开销和加锁时间界于表锁和行锁之间，并发度一般。应用在BDB 存储引擎中。</li>
</ul>
</li>
<li>从操作的类型可分为读锁和写锁<ul>
<li>读锁（S锁）：共享锁，针对同一份数据，多个读操作可以同时进行而不会互相影响。</li>
<li>写锁（X锁）：排他锁，当前写操作没有完成前，它会阻断其他写锁和读锁。</li>
</ul>
</li>
<li>从操作的性能可分为乐观锁和悲观锁。<ul>
<li>乐观锁：一般的实现方式是对记录数据版本进行比对，在数据更新提交的时候才会进行冲突检测，如果发现冲突了，则提示错误信息。</li>
<li>悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，再修改的控制方式。共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。</li>
</ul>
</li>
</ul>
<h5 id="8-5-2-悲观锁"><a href="#8-5-2-悲观锁" class="headerlink" title="8.5.2 悲观锁"></a>8.5.2 悲观锁</h5><p>悲观锁（Pessimistic Locking），是指在数据处理过程，将数据处于锁定状态，一般使用数据库的锁机制实现。从广义上来讲，前面提到的行锁、表锁、读锁、写锁、共享锁、排他锁等，这些都属于悲观锁范畴。</p>
<p>表锁：表级读锁会阻塞写操作，但是不会阻塞读操作。而写锁则会把读和写操作都阻塞。</p>
<p>共享锁：是行锁-读锁，事务使用了共享锁（读锁），只能读取，不能修改，修改操作被阻塞。</p>
<p>排它锁：是行锁-写锁。事务使用了排他锁（写锁），当前事务可以读取和修改，其他事务不能修改，也不能获取记录</p>
<h5 id="8-5-3-乐观锁"><a href="#8-5-3-乐观锁" class="headerlink" title="8.5.3 乐观锁"></a>8.5.3 乐观锁</h5><p>乐观锁是相对于悲观锁而言的，它不是数据库提供的功能，需要开发者自己去实现。在数据库操作时，想法很乐观，认为这次的操作不会导致冲突，因此在数据库操作时并不做任何的特殊处理，即不加锁，而是在进行事务提交时再去判断是否有冲突了。</p>
<p>乐观锁实现的关键点：冲突的检测。</p>
<p>悲观锁和乐观锁都可以解决事务写写并发，在应用中可以根据并发处理能力选择区分，比如对并发率要求高的选择乐观锁；对于并发率要求低的可以选择悲观锁。</p>
<p>实现方式：添加版本和时间戳</p>
<h5 id="8-5-4-死锁"><a href="#8-5-4-死锁" class="headerlink" title="8.5.4 死锁"></a>8.5.4 死锁</h5><p>死锁产生的四个必要条件：</p>
<p>互斥条件：一个资源同一时刻只能被一个进程占用。</p>
<p>不可剥夺：一个资源除非被占用的进程主动释放，否则不能被剥夺</p>
<p>请求保持：一个进行请求资源时，没有获取到则保持请求，直到获取资源</p>
<p>循环等待：进程a 等待进程b 持有的资源，进程b 等待进程a 持有的资源</p>
<p>破坏其中一个条件就可以避免死锁。</p>
<h4 id="8-6-mysql-事务"><a href="#8-6-mysql-事务" class="headerlink" title="8.6 mysql 事务"></a>8.6 mysql 事务</h4><h5 id="8-6-1-事务特性"><a href="#8-6-1-事务特性" class="headerlink" title="8.6.1 事务特性"></a>8.6.1 事务特性</h5><p>mysql 事务有4个特性，即所谓的 ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p>
<p>原子性：事务是一个原子操作单元，对数据的修改，要么全都执行，要么全都不执行。</p>
<p>一致性：是指事务在开始前和事务结束后，数据库的完整性限制没有被破坏。</p>
<p>隔离性：是指一个事务的执行，不会被其他事务干扰，一个事务的内部操作及使用的数据对其他的并发事务是隔离的。</p>
<p>持久性：指事务一旦提交，它对数据库中的数据修改时永久性的，后续操作不会对其有任何影响，不会丢失。</p>
<h5 id="8-6-2-事务隔离级别"><a href="#8-6-2-事务隔离级别" class="headerlink" title="8.6.2 事务隔离级别"></a>8.6.2 事务隔离级别</h5><p>数据库系统提供了以下 4 种事务隔离级别</p>
<ul>
<li>读未提交：解决了回滚覆盖类型的更新丢失，但可能发生脏读现象(一个事务读取到了另一个事务修改但未提交的数据)，也就是可能读取到其他会话中未提交事务修改的数据。</li>
<li>已提交读：只能读取到其他会话中已经提交的数据，解决了脏读。但可能发生不可重复读现象(一个事务中多次读取同一行记录不一致，后面读取的跟前面读取的不一致)，也就是可能在一个事务中两次查询结果不一致。</li>
<li>可重复度：解决了不可重复读，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上会出现幻读(一个事务中多次按相同条件查询，结果不一致。后续查询的结果和面前查询结果不同，多了或少了几行记录)，简单的说幻读指的的当用户读取某一范围的数据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。</li>
<li>可串行化：所有的增删改查串行执行。它通过强制事务排序，解决相互冲突，从而解决幻度的问题。这个级别可能导致大量的超时现象的和锁竞争，效率低下</li>
</ul>
<h5 id="8-6-3-MVCC"><a href="#8-6-3-MVCC" class="headerlink" title="8.6.3 MVCC"></a>8.6.3 MVCC</h5><p>多版本控制，支持读读、读写、写读并行。但为了保证一致性，写写是无法并行的。</p>
<p>在事务1开始写操作的时候会copy一个记录的副本，其他事务读操作会读取这个记录副本，因此不会影响其他事务对此记录的读取，实现写和读并行。</p>
<h4 id="8-7-mysql-分库分表"><a href="#8-7-mysql-分库分表" class="headerlink" title="8.7 mysql 分库分表"></a>8.7 mysql 分库分表</h4><p>使用分库分表时，主要有垂直拆分和水平拆分两种拆分模式，都属于物理空间的拆分。</p>
<p>垂直拆分：由于表数量多导致的单个库大。将表拆分到多个库中。</p>
<p>水平拆分：由于表记录多导致的单个库大。将表记录拆分到多个表中。</p>
<h5 id="8-7-1-主键策略"><a href="#8-7-1-主键策略" class="headerlink" title="8.7.1 主键策略"></a>8.7.1 主键策略</h5><p>1、uuid</p>
<p>2、雪花片算法。ID 按照时间有序生成。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号，最后还有一个符号位，永远是0</p>
<p>3、redis 生成id.利用 redis 的原子操作 INCR 来实现。</p>
<h5 id="8-7-2-分片策略"><a href="#8-7-2-分片策略" class="headerlink" title="8.7.2 分片策略"></a>8.7.2 分片策略</h5><p>1、范围分片</p>
<p>2、hash 取模分片</p>
<p>3、一致性hash 分片</p>
<h4 id="8-8-mysql-主从同步"><a href="#8-8-mysql-主从同步" class="headerlink" title="8.8 mysql 主从同步"></a>8.8 mysql 主从同步</h4><h5 id="8-8-1-适用场景"><a href="#8-8-1-适用场景" class="headerlink" title="8.8.1 适用场景"></a>8.8.1 适用场景</h5><p>MySQL 主从模式是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，从节点可以复制主数据库中的所有数据库，或者特定的数据库，或者特定的表。</p>
<h5 id="8-8-2-主从同步作用"><a href="#8-8-2-主从同步作用" class="headerlink" title="8.8.2 主从同步作用"></a>8.8.2 主从同步作用</h5><p>1、实时灾备，用于故障切换</p>
<p>2、读写分离，提供查询服务</p>
<p>3、数据备份，避免影响业务（高可用）</p>
<h5 id="8-8-3-主从同步实现原理"><a href="#8-8-3-主从同步实现原理" class="headerlink" title="8.8.3 主从同步实现原理"></a>8.8.3 主从同步实现原理</h5><p>主要分为三个步骤</p>
<p>1、主库将数据库的变更记录到Binlog 日志文件中</p>
<p>2、从库读取主库的 Binlog 日志文件信息写入到从库的 Ready log 日志中。</p>
<p>3、从库读取 Ready Log 日志信息在从库中 Replay ,更新从库信息</p>
<p>异步复制：master 不会等待slave 节点返回，直接提交事务，会导致数据不一致。</p>
<p>半同步复制：master 会等待slave 节点的ack 消息后才会进行事务提交。</p>
<h3 id="9-redis"><a href="#9-redis" class="headerlink" title="9. redis"></a>9. redis</h3><h4 id="9-1-跳跃表"><a href="#9-1-跳跃表" class="headerlink" title="9.1 跳跃表"></a>9.1 跳跃表</h4><p>跳跃表是有序集合的底层实现。就是将有序集合的部分节点进行分层。每一层都是有序集合，并且层次越高，节点数量就越少。最底层的包含所有节点数据。典型的空间换时间。</p>
<h4 id="9-2-字典"><a href="#9-2-字典" class="headerlink" title="9.2 字典"></a>9.2 字典</h4><p>字典是 redis 用来存储键值对的一种数据结构。</p>
<p>hash 函数： 把redis 的key(字符串、整型、浮点型)统一转换成统一长度的整数。</p>
<p>hash 冲突：采用单链表解决。</p>
<p>字典扩容：新申请的容量为原来的一倍，将老的数据迁移到新字典中需要rehash。比较缓慢。</p>
<h4 id="9-3-压缩列表"><a href="#9-3-压缩列表" class="headerlink" title="9.3 压缩列表"></a>9.3 压缩列表</h4><p>由一系列特殊编码的连续内存块组成的顺序型数据结构。没有压缩列表包头部、entry数据和尾部。头部信息包含压缩列表的字节长度、压缩列表尾部元素的偏移量、压缩列表元素个数；尾部为一个字节，为结束标志。</p>
<p>entry 数据包含：前一个元素的字节长度、当前元素的编码、以及当前元素的数据内容。</p>
<h4 id="9-4-快速列表"><a href="#9-4-快速列表" class="headerlink" title="9.4 快速列表"></a>9.4 快速列表</h4><p>quicklist 是列表的底层实现。quicklist 是一个双向链表，同时每个节点是一个压缩列表。这样quicklist 的每个节点都可以存储多个元素。</p>
<h4 id="9-5-缓存过期和淘汰策略"><a href="#9-5-缓存过期和淘汰策略" class="headerlink" title="9.5 缓存过期和淘汰策略"></a>9.5 缓存过期和淘汰策略</h4><h5 id="9-5-1-过期删除策略"><a href="#9-5-1-过期删除策略" class="headerlink" title="9.5.1 过期删除策略"></a>9.5.1 过期删除策略</h5><p>redis 淘汰策略有三种。定时删除、惰性删除和主动删除。</p>
<p>Redis 目前采用惰性删除和主动删除。</p>
<h6 id="9-5-1-1-定时删除"><a href="#9-5-1-1-定时删除" class="headerlink" title="9.5.1.1 定时删除"></a>9.5.1.1 定时删除</h6><p>在设置键的过期时间时，创建一个定时器，让定时器在该键过期时，执行对键的删除操作。（需要创建定时器，消耗cpu）</p>
<h6 id="9-5-1-2-惰性删除"><a href="#9-5-1-2-惰性删除" class="headerlink" title="9.5.1.2 惰性删除"></a>9.5.1.2 惰性删除</h6><p>在访问 key 的时候发现它失效了，就删除这个key</p>
<h6 id="9-5-1-3-主动删除-定期删除"><a href="#9-5-1-3-主动删除-定期删除" class="headerlink" title="9.5.1.3 主动删除(定期删除)"></a>9.5.1.3 主动删除(定期删除)</h6><p>每隔一段时间，我们就对一些key 进行检查，删除过期的 key</p>
<h5 id="9-5-2-淘汰策略"><a href="#9-5-2-淘汰策略" class="headerlink" title="9.5.2 淘汰策略"></a>9.5.2 淘汰策略</h5><h6 id="9-5-2-1-LRU"><a href="#9-5-2-1-LRU" class="headerlink" title="9.5.2.1 LRU"></a>9.5.2.1 LRU</h6><p>LRU （Least recently used ）最近最少使用。基于链表实现，每次新数据插入到链表头部，如果链表中的节点有被用到，就将该节点移到链表头部。这样链表尾部的元素就是最近最少使用的了。删除的 时候从尾部开始删除。</p>
<p>volatile-lru：从已经设置过期的数据集中挑选最近最少使用的进行数据淘汰。</p>
<p>allkeys-lru：从所有数据集中挑选最近最少使用的数据进行淘汰。</p>
<h6 id="9-5-2-2-随机"><a href="#9-5-2-2-随机" class="headerlink" title="9.5.2.2 随机"></a>9.5.2.2 随机</h6><p>从数据集中任意选择一个数据淘汰</p>
<h6 id="9-5-2-3-volatile-ttl"><a href="#9-5-2-3-volatile-ttl" class="headerlink" title="9.5.2.3 volatile-ttl"></a>9.5.2.3 volatile-ttl</h6><p>从已经设置过期时间的数据集中挑选将要过期的数据进行淘汰。从过期时间表中随机挑选几个键值对，取出其中ttl 最小的键值对进行淘汰。</p>
<h4 id="9-6-缓存穿透、缓存雪崩、缓存击穿"><a href="#9-6-缓存穿透、缓存雪崩、缓存击穿" class="headerlink" title="9.6 缓存穿透、缓存雪崩、缓存击穿"></a>9.6 缓存穿透、缓存雪崩、缓存击穿</h4><h5 id="9-6-1-缓存穿透"><a href="#9-6-1-缓存穿透" class="headerlink" title="9.6.1 缓存穿透"></a>9.6.1 缓存穿透</h5><p>缓存穿透是指在高并发下查询 key 不存在数据，会穿透缓存查询数据库，导致数据库压力过大而宕机。</p>
<p>解决方案：</p>
<p>一：设置一个短暂的随机延时，避免同一时刻所有的请求都穿过缓存增大数据的压力。这样先从数据库查询的数据查询出后，添加到缓存中，其他的请求就不会从数据库中请求了。</p>
<p>二：设置布隆过滤器，在缓存之前再加一个层布隆过滤器，在查询的时候先去布隆过滤器中查询key 是否存在，如果不存在就直接返回，如果存在再查询缓存和DB.</p>
<p>布隆过滤器的原理是一组hash函数。当一个元素被加入集合中时，通过k个 hash 函数将这个元素映射成一个数据中的k个点，把他们置为1。检索是，我们只要看看这些点是不是1就知道集合中存不存在这个元素了。只要有一个点为0，则被检测的元素一定不存在集合中。</p>
<h5 id="9-6-2-缓存雪崩"><a href="#9-6-2-缓存雪崩" class="headerlink" title="9.6.2 缓存雪崩"></a>9.6.2 缓存雪崩</h5><p>大量缓存集中在某一时间段内失效，这样在失效的时候，大量请求达到数据库，造成数据库崩溃。</p>
<p>解决方案：</p>
<p>1、key 的失效期分散开，不同的key 设置不同的有效期。</p>
<p>2、设置二级缓存</p>
<p>3、搭建集群。单节点故障后，由从节点补上。</p>
<h5 id="9-6-3-缓存击穿"><a href="#9-6-3-缓存击穿" class="headerlink" title="9.6.3 缓存击穿"></a>9.6.3 缓存击穿</h5><p>主要针对热点数据，当key 在某一时间点过期的时候，正好有大量的并发请求访问这个key。从而请求都达到数据库，加大的数据库压力。</p>
<p>解决方案：</p>
<p>1、针对热点 key.不设置超时时间。定期的充数据库同步到redis 中。</p>
<p>2、用分布式锁控制访问的线程。使用redis 的setnx互斥锁进行判断，只有获取锁的线程才能访问数据库，其他的线程进行等待。</p>
<h4 id="9-7-单线程的Redis-为什么这么快"><a href="#9-7-单线程的Redis-为什么这么快" class="headerlink" title="9.7 单线程的Redis 为什么这么快"></a>9.7 单线程的Redis 为什么这么快</h4><p>1、正常情况下都是内存操作，不会和磁盘交换，从而访问速度更快。</p>
<p>2、单线程没有锁，没有多线程的切换和调度，不会死锁，没有性能损耗。</p>
<p>3、采用I/O 多路复用模型，非阻塞io 。效率更高</p>
<p>4、数据结构简单，压缩处理。</p>
<h4 id="9-8-redis-分布式锁实现"><a href="#9-8-redis-分布式锁实现" class="headerlink" title="9.8 redis 分布式锁实现"></a>9.8 redis 分布式锁实现</h4><p>加锁：使用setnx 加锁，如果执行成功，然后设置过期时间。</p>
<p>解锁：删除加锁的key</p>
<h3 id="10-中间件"><a href="#10-中间件" class="headerlink" title="10. 中间件"></a>10. 中间件</h3><h4 id="10-1-zookeeper"><a href="#10-1-zookeeper" class="headerlink" title="10.1 zookeeper"></a>10.1 zookeeper</h4><h6 id="10-1-1-zookeeper-数据结构"><a href="#10-1-1-zookeeper-数据结构" class="headerlink" title="10.1.1 zookeeper 数据结构"></a>10.1.1 zookeeper 数据结构</h6><p>zookeeper 将所有的数据存储在内存中，数据模型是一个Znode tree。用斜杠分割路径，每个znode 上还保留自己的数据内容，同时保留一系列的属性信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411115516214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NzkwMDEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可以根据需求创建如下四种类型的节点：</p>
<p>持久节点：在节点创建后，会一直存在服务器上，直到删除操作主动删除。</p>
<p>持久顺序节点：和持久节点一样，创建后就一直存在，并且多了一个特性，在创建节点的时候，会加上一个数字后缀，来表示顺序。</p>
<p>临时节点：它的生命周期和客户端会话绑定在一起，客户端会话结束，节点就会被删除掉。如持续节点不同的是，临时节点不能创建子节点。</p>
<p>临时顺序节点：有顺序的临时节点，相对于临时节点而言，在创建的时候，会加一个数字后缀，表示顺序。</p>
<h6 id="10-1-2-监听器"><a href="#10-1-2-监听器" class="headerlink" title="10.1.2 监听器"></a>10.1.2 监听器</h6><p>Watcher(事件监听器)是zookeeper 中一个重要的特性，zookeeper 允许用户在指定的节点上注册一些watcher。并在一些特定的事件触发的时候，zookeeper 服务端会将事件通知到感兴趣的客户端。</p>
<h6 id="10-1-3-zookeeper-应用场景"><a href="#10-1-3-zookeeper-应用场景" class="headerlink" title="10.1.3 zookeeper 应用场景"></a>10.1.3 zookeeper 应用场景</h6><p>1、数据发布订阅</p>
<p>2、集群管理</p>
<p>3、分布式锁。利用zookeeper 可以实现分布式锁的排它锁和共享锁。</p>
<p>排他锁：利用zk 的强一致性，以及临时节点的特性。首先定义一二锁节点。然后多线程在锁节点下创建一个临时节点，哪个节点创建成功了，就说明该线程获取到了分布式锁，没有获取到锁的线程，就注册一个所节点的子节点监听事件，以便监听到锁节点的变化情况。如果一个线程执行完成或者执行异常，都会关闭连接，表示释放了锁，这样其他节点就可以通过监听事前来重新获取锁了。</p>
<p>共享锁：一样的是利用zk 节点的强一致性。不过创建的是顺序的临时节点。分别表示读锁和写锁。对于读请求，如果没有比自己小的节点或者所有比自己小的节点都是读请求，那么表明自己已经成功的获取到了共享锁，开始执行读取逻辑。对于写请求，如果自己不是序号最小的节点，就需要等待。</p>
<p>4、分布式队列</p>
<h6 id="10-1-4-ZAB-协议"><a href="#10-1-4-ZAB-协议" class="headerlink" title="10.1.4 ZAB 协议"></a>10.1.4 ZAB 协议</h6><p>在 zookeeper 中主要是利用原子广播协议来保证数据一致性的。</p>
<p>ZAB 协议的核心是定义了对于那些会改变 Zookeeper 服务器数据状态的事务请求的处理方式<br>即：所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，余下的服务器则称为Follower服务器，Leader服务器负责将一个客户端事务请求转化成一个事务Proposal(提议）,并将该Proposa1分发给集群中所有的Follower服务器，之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/52c95e5d787eb4ae474019e7d348e99c.png" alt="image-20200720181011476"></p>
<h5 id="10-2-dubbo"><a href="#10-2-dubbo" class="headerlink" title="10.2 dubbo"></a>10.2 dubbo</h5><p>在集群负载均衡时，dubbo 提供了多种均衡策略。包含随机、轮询、最小活跃调用数、一致性hash。 默认为随机调用。</p>
<h3 id="11-分布式"><a href="#11-分布式" class="headerlink" title="11. 分布式"></a>11. 分布式</h3><h4 id="11-1-分布式下读写一致性"><a href="#11-1-分布式下读写一致性" class="headerlink" title="11.1 分布式下读写一致性"></a>11.1 分布式下读写一致性</h4><p>用户读取自己结果的一致性。保证用户永远能够第一时间看到自己更新的内容。</p>
<p>如：我们发朋友圈，别人能不能第一时间看到没关系，但是需要我们自己第一时间就能看到，这个应该怎么实现？</p>
<p>解决方案：</p>
<p>1、我们设置一个更新时间窗口，在刚刚更新的这段时间内，我们默认都从主库读取，过了这个窗口后，挑选最近有从主库更新的从库读取。</p>
<p>2、我们直接记录用户操作的时间戳。在请求的时候，直接把这个时间戳带上，凡是最后更新时间小于这个时间戳的分库就不予以响应。</p>
<h4 id="11-2-单调一致性"><a href="#11-2-单调一致性" class="headerlink" title="11.2 单调一致性"></a>11.2 单调一致性</h4><p>本次读取到的数据不能比上次读取到的数据旧。</p>
<p>解决方案：</p>
<p>根据用户id 计算hash 值，映射到对应的服务器上，这样同一个用户不管怎样刷新，都会被映射到同一台机器，保证不会出现数据变旧的情况。</p>
<h4 id="11-3-CAP-理论"><a href="#11-3-CAP-理论" class="headerlink" title="11.3 CAP 理论"></a>11.3 CAP 理论</h4><p>一个分布式系统不能同时满足一致性、可用性、分区容错性这三个基本需求，只能满足其中两个。</p>
<h4 id="11-4-BASE-理论"><a href="#11-4-BASE-理论" class="headerlink" title="11.4 BASE 理论"></a>11.4 BASE 理论</h4><p>BASE 由三个单词组成。基本可用(Basically Available)、软状态(Soft state)、最终一致性(Eventually consistent)。核心是想是：即使无法做到强一致性，但是每个应用都可以根据自己的特点，采用适当的方式来使得系统达到最终一致性。</p>
<h4 id="11-5-2PC-和-3PC"><a href="#11-5-2PC-和-3PC" class="headerlink" title="11.5 2PC 和 3PC"></a>11.5 2PC 和 3PC</h4><p>两阶段提交协议：分为准备阶段和提交阶段。在准备阶段，事务管理器会给每个参入者发送prepare 消息，每个参数者在自己本地执行事务，并写入undo/redo 日志(undo 是修改前的日志，用于事务回滚，redo是修改后的日志，用来数据提交)，这个时候事务还没有提交。在提交阶段，如果事务管理器收到了参入者执行失败或者超时的消息时，会发送回滚的消息给所有参入者进行回滚。如果都成功了，就发送提交的消息给所有参入者进行数据提交操作。</p>
<p>三阶段提交协议：是将2PC 的提交阶段一分为二。precommit 阶段发送预提交请求，各个参入者向协调者反馈执行结果。docommit 阶段执行事务提交。</p>
<h4 id="11-6-paxos-一致性算法"><a href="#11-6-paxos-一致性算法" class="headerlink" title="11.6 paxos 一致性算法"></a>11.6 paxos 一致性算法</h4><p>paxos 算法核心就是提案。</p>
<p>1、proposer 选择一个提案为N ,向半数以上的Acceptor 发送编号为N 的 prepare 请求。</p>
<p>2、如果 Acceptor 收到一个编号为N的 prepare请求，并且N为当前Acceptor 所响应的请求中编号最大的，它就接收这个提案，并且不再接收比这个编号更小的提案了。</p>
<p>3、如果proposer 收到了半数以上Acceptor 对其发出的编号为N 的prepare请求响应。就会给半数以上的 Acceptor 发送提案的accept 请求。</p>
<p>4、如果acceptor 收到一个编号为N的accept 请求，如果当前acceptor 没有对编号大于N 的prepare 请求做出响应，它就接收该提案。</p>
<h4 id="11-7-Raft-一致性算法"><a href="#11-7-Raft-一致性算法" class="headerlink" title="11.7 Raft 一致性算法"></a>11.7 Raft 一致性算法</h4><p>Raft 一致性算法分为两个阶段：首先是选举阶段，然后通过选举出来的领导人带领进行正常操作。</p>
<p>选举的过程：</p>
<p>1、集群中所有的节点开始的时候都是 follower 跟随者。当发现没有领导者的时候，</p>
<p>2、部分的跟随者会变成候选者，候选者会向跟随者发起投票请求。如果当前候选者获得了超过半数的选票，就自动变成了领导者。</p>
<p>3、如果集群中存在领导者，其他的候选者也会变成跟随者，所有的跟随者都会从领导者中进行数据同步，保证数据一致性。</p>
<h3 id="12-mybatis"><a href="#12-mybatis" class="headerlink" title="12. mybatis"></a>12. mybatis</h3><h4 id="12-1-mybatis-初始化"><a href="#12-1-mybatis-初始化" class="headerlink" title="12.1 mybatis 初始化"></a>12.1 mybatis 初始化</h4><p>1、通过jdk 文件流加载器读取xml配置文件。</p>
<p>2、通过XmlConfigBuilder 来解析配置文件，并封装到configuration 对象中。</p>
<p>3、创建SqlSessionFactory 对象，并传递configuration</p>
<p>4、通过SqlSessionFactory.openSqlSession() 来创建sqlSession 对象并返回。</p>
<h4 id="12-2-sql-执行过程"><a href="#12-2-sql-执行过程" class="headerlink" title="12.2 sql 执行过程"></a>12.2 sql 执行过程</h4><p>1、通过调用Sqlsession 对象的query()或者update() 方法。</p>
<p>2、通过statmentid 从configuration 中获取到对应的mapperstatement</p>
<p>3、将configuration 和mapperstatement 对象传递给Executor 执行器来执行sql 操作。</p>
<p>4、Executor 执行器用来处理缓存，以及动态sql 的生成，并将sql 传递给statementhandle</p>
<p>5、statementHandle 将调用parameterHandle 进行参数的解析</p>
<p>6、statementHandle 执行sql 得到结果。</p>
<p>7、statementHandle 通过ResultSetHandle 将返回的结果进行对象映射，最终返回结果。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2019/07/12/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            spring常用配置文件
          
        </div>
      </a>
    
    
      <a href="/2019/07/04/mybatis/tkmapper/TKMybatis/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">TKMybatis</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "B930dASMl8AivIQlQp9hVVtO-gzGzoHsz",
    app_key: "WwsXDv9Vdc5BzBNUc5HzKLj2",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2018-2021
        <i class="ri-heart-fill heart_icon"></i> WangYinggang
      </li>
    </ul>
    
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="WinGone&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/1.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/2.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
</body>

</html>